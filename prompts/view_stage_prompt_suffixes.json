{
    "ExcludeFields": "Excludes the specified fields in the current view. All fields except the excluded fields will be present in the view.",
    "Exists": "Filters the samples in the current view to only include samples that have (or do not have) a non-`None` value for the given field or embedded field.",
    "FilterField": "Filters the samples in the view by the specified field and filtering expression. Can be applied to fields of type `int`, `float`, `bool`, `str`, `date`, and `datetime`.",
    "FilterLabels": "Filters the samples in the view to only include the labels within the specified label field that match the described expression.",
    "GeoNear": "Sort the samples in the view by their proximity to a specified geolocation, optionally filtering by minimum and maximum distances.",
    "GeoWithin": "Filter the samples in the view to only include samples that are within a specified geographical region.",
    "GroupBy": "Groups the samples in the view by the specified field, embedded field, or expression.",
    "Limit": "You are a helpful assistant for computer vision researchers and engineers using the FiftyOne library. Your task is to help users create views in the FiftyOne App by providing them with the appropriate `ViewStages` that can be used to filter, sort, slice, match, and transform their datasets. For this task, you need to help users",
    "LimitLabels": "Limits the number of `Label` instances in the specified labels list field of each sample in the collection.",
    "MapLabels": "Maps the labels in the specified label field of each sample in the collection using the provided mapping dictionary.",
    "Match": "Filters the samples in the view to only include samples that match the described expression.",
    "MatchLabels": "Filters the samples in the view to only include samples that have at least one label that matches the described expression. This can be applied to all label fields, or to specific label fields.",
    "MatchTags": "Returns a view containing the samples in the collection that have or don't have any/all of the given tag(s).",
    "SelectBy": "Selects the samples with the given field values from the collection.\n\nThis stage is typically used to work with categorical fields (strings, ints, and bools). If you want to select samples based on floating point fields, use :meth:`match`.",
    "SelectFields": "Select the specified fields in the current view. Only the selected fields (and default fields like `id`, `tags`) will be present in the view.",
    "SelectGroupSlices": "Selects the samples in a group collection from the given slice(s). The returned view is a flattened non-grouped view containing only the slice(s) of interest.",
    "SelectLabels": "Selects only the specified labels from the collection.\n\nThe returned view will omit samples, sample fields, and individual labels that do not match the specified selection criteria.",
    "Shuffle": "Shuffle the samples in the view. This stage shuffles the samples in the view randomly.",
    "Skip": "Skip the specified number of samples in the view. The `skip` parameter specifies the number of samples to skip.",
    "SortBy": "Sorts the samples in the view by the specified field, embedded field, or expression. The `reverse` parameter specifies whether to sort in ascending (False) or descending (True) order.",
    "SortBySimilarity": "Sorts the samples in the view by their similarity to the specified text query.",
    "Take": "Pick `take` random samples from the view. The `take` parameter specifies the number of samples to take.",
    "ToPatches": "Create a view that contains one sample per object patch in the specified field of the collection.",
    "ToEvaluationPatches": "Creates a view based on the results of the evaluation with the given key that contains one sample for each true positive, false positive, and false negative example in the collection, respectively. True positive examples will result in samples with both their ground truth and predicted fields populated, while false positive/negative examples will only have one of their corresponding predicted/ground truth fields populated, respectively.\n\nIf multiple predictions are matched to a ground truth object (e.g., if the evaluation protocol includes a crowd attribute), then all matched predictions will be stored in the single sample along with the ground truth object.\n\nThe returned view will also have top-level ``type`` and ``iou`` fields populated based on the evaluation results for that example, as well as a ``sample_id`` field recording the sample ID of the example, and a ``crowd`` field if the evaluation protocol defines a crowd attribute."
}
